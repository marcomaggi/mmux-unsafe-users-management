#
# Part of: MMUX Unsafe Users Management
# Contents: unsafe users management script
# Date: Oct 11, 2014
#
# Abstract
#
#	This is the  do-it-all script for managing the  unsafe users as defined by  the package MMUX
#	Unsafe Users Management.
#
# Copyright (C) 2014, 2018, 2020 Marco Maggi <mrc.mgg@gmail.com>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU
# General Public  License as  published by  the Free Software  Foundation, either  version 3  of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that  it will be useful, but WITHOUT ANY WARRANTY; without
# even the  implied warranty of MERCHANTABILITY  or FITNESS FOR  A PARTICULAR PURPOSE.  See  the GNU
# General Public License for more details.
#
# You should  have received a copy  of the GNU General  Public License along with  this program.  If
# not, see <http://www.gnu.org/licenses/>.
#

#page
#### global variables

declare -r script_PROGNAME=mmux-unsafe-users-manager
declare -r script_VERSION=0.3.1
declare -r script_COPYRIGHT_YEARS='2014, 2018'
declare -r script_AUTHOR='Marco Maggi'
declare -r script_LICENSE=GPL
declare script_USAGE="usage: ${script_PROGNAME} [action] [options]"
declare script_DESCRIPTION='Unsafe users management operations.'
declare script_EXAMPLES=

declare -r script_REQUIRED_MBFL_VERSION=v3.0.0-devel.6
declare -r COMPLETIONS_SCRIPT_NAMESPACE='p-mmux-unsafe-users-manager'

### ------------------------------------------------------------------------

declare -r prefix="@prefix@"
declare -r exec_prefix="@exec_prefix@"
declare -r sbindir="@sbindir@"
declare -r sysconfdir="@sysconfdir@"

# We need this because this script will invoke itself.
#
declare -r SCRIPT_ARGV0="$0"

# Safe users group name, at most 16 characters.
#
#                           0123456789012345
declare -r SAFE_USERS_GROUP=mmux-safe-usrs

# Unsafe users group name, at most 16 characters.
#
#                             0123456789012345
declare -r UNSAFE_USERS_GROUP=mmux-unsafe-usrs

# The policy file establishing who can call this script using "sudo" to become the superuser.
#
declare -r SUDOERS_CONF_DIRECTORY_PATHNAME="$sysconfdir"/sudoers.d
declare -r SUDOERS_CONF_FILE_PATHNAME="$SUDOERS_CONF_DIRECTORY_PATHNAME"/mmux-unsafe-users-management.conf

declare -r MANAGER_SCRIPT_PATHNAME="$sbindir"/"$script_PROGNAME"
declare -r MMUX_XINITRC_DIRECTORY_PATHNAME="$sysconfdir"/mmux/xinitrc.d
declare -r MMUX_XINITRC_SCRIPT_PATHNAME="$MMUX_XINITRC_DIRECTORY_PATHNAME"/mmux-unsafe-users-management.sh

### ------------------------------------------------------------------------

# All the home directories of unsafe users will be created under this base directory.
#
declare -r DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY=/home/unsafe-users

declare -r DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE='0750'
declare -r DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER='root'
declare -r DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP=$UNSAFE_USERS_GROUP

### ------------------------------------------------------------------------

# Access permissions for the home directory of an unsafe user.
#
declare -r DEFAULT_UNSAFE_USERHOME_MODE='u+rwx-s,g+rwxs,o-rwxs'

# Access permissions for the directories in the subdirectory tree of the home directory of an unsafe
# user.
#
declare -r DEFAULT_UNSAFE_USERHOME_DIRECTORIES_MODE='u+rwx-s,g+rwxs,o-rwxs'

# Access permissions for the files in the subdirectory tree of the home directory of an unsafe user.
#
declare -r DEFAULT_UNSAFE_USERHOME_FILES_MODE='u-s,g-s,o-rwxs'

#page
#### library loading

mbfl_embed_library

#page
#### program declarations

mbfl_dialog_enable_programs

mbfl_program_enable_sudo
mbfl_file_enable_remove

mbfl_declare_program find
mbfl_declare_program grep
mbfl_declare_program install
mbfl_declare_program xhost

self_PROGRAM_USERADD='@MMUX_PROGRAM_USERADD@'
self_PROGRAM_USERDEL='@MMUX_PROGRAM_USERDEL@'
self_PROGRAM_USERMOD='@MMUX_PROGRAM_USERMOD@'
self_PROGRAM_GROUPADD='@MMUX_PROGRAM_GROUPADD@'
self_PROGRAM_GROUPDEL='@MMUX_PROGRAM_GROUPDEL@'
self_PROGRAM_GROUPMOD='@MMUX_PROGRAM_GROUPMOD@'
self_PROGRAM_INSTALL='@MMUX_PROGRAM_INSTALL@'

#page
#### declare exit codes

mbfl_main_declare_exit_code 2 invalid_safe_username
mbfl_main_declare_exit_code 3 invalid_unsafe_username
mbfl_main_declare_exit_code 4 invalid_base_directory_for_unsafe_users_home_directories
mbfl_main_declare_exit_code 5 unable_to_determine_effective_username

#page
#### configure global behaviour

mbfl_atexit_enable
mbfl_location_enable_cleanup_atexit

#page
#### script actions

mbfl_declare_action_set HELP
mbfl_declare_action HELP	HELP_USAGE	NONE		usage		'Print the help screen and exit.'
mbfl_declare_action HELP	HELP_PRINT_COMPLETIONS_SCRIPT NONE print-completions-script 'Print the completions script for this program.'

## --------------------------------------------------------------------

mbfl_declare_action_set MAIN
mbfl_declare_action MAIN SETUP		NONE setup		'Prepare system for package usage.'
mbfl_declare_action MAIN ADD		NONE add		'Add an unsafe user.'
mbfl_declare_action MAIN DEL		NONE del		'Delete an unsafe user.'
mbfl_declare_action MAIN ENABLE_X	NONE enable-x		'Enable unsafe users running X applications in safe user X server.'
mbfl_declare_action MAIN DISABLE_X	NONE disable-x		'Disable unsafe users running X applications in safe user X server.'
mbfl_declare_action MAIN NORMALISE	NONE normalise		'Normalise the home directories of unsafe users.'
mbfl_declare_action MAIN SUDO_ADD	NONE sudo-add		'Internal action.'
mbfl_declare_action MAIN SUDO_DEL	NONE sudo-del		'Internal action.'
mbfl_declare_action MAIN SUDO_SETUP	NONE sudo-setup		'Internal action.'
mbfl_declare_action MAIN SUDO_NORMALISE	NONE sudo-normalise	'Internal action.'
mbfl_declare_action MAIN HELP		HELP help		'Help the user of this script.'

#page
#### prepare the system for package usage

function script_before_parsing_options_SETUP () {
    script_USAGE="usage: ${script_PROGNAME} setup [options]"
    script_DESCRIPTION='Prepare the system for package use.'
    mbfl_declare_option UNSAFE_USERS_HOME_BASE_DIRECTORY "$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY" \
			'' unsafe-home-base witharg 'Select the base directory for the unsafe users\x27 home directories.'
}
function script_action_SETUP () {
    mbfl_message_verbose_printf 'setting up the system for MMUX Unsafe Users Manager use.\n'

    if ! mbfl_wrong_num_args 0 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_local_varref(SUBSCRIPT_FLAGS)
    mbfl_getopts_gather_mbfl_options_var mbfl_datavar(SUBSCRIPT_FLAGS)

    mbfl_program_declare_sudo_user root
    if {
	mbfl_location_enter
	{
	    mbfl_location_handler_suspend_testing
	    mbfl_program_exec "$SCRIPT_ARGV0" sudo-setup "$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY" $SUBSCRIPT_FLAGS
	}
	mbfl_location_leave
    }
    then exit_success
    else
    	mbfl_message_error 'performing system setup'
    	exit_because_failure
    fi
}

### ------------------------------------------------------------------------

function script_before_parsing_options_SUDO_SETUP () {
    script_USAGE="usage: ${script_PROGNAME} sudo-setup UNSAFE_USERS_HOME_BASE_DIRECTORY [options]"
    script_DESCRIPTION='Internal action.'
}
function script_action_SUDO_SETUP () {
    if ! mbfl_wrong_num_args 1 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_command_line_argument(UNSAFE_USERS_HOME_BASE_DIRECTORY, 0)

    setup_create_safe_users_group
    setup_create_unsafe_users_group
    if mbfl_file_is_directory "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
    then setup_normalise_base_directory_for_unsafe_users_home_directories "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
    else setup_create_base_directory_for_unsafe_users_home_directories    "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
    fi
    setup_check_sudoers_conf_directory
    setup_check_sudoers_conf_file
    setup_normalise_this_script_itself
    if mbfl_file_is_directory "$MMUX_XINITRC_DIRECTORY"
    then setup_normalise_xinitrc_directory
    else create_normalise_xinitrc_directory
    fi
    setup_normalise_xinitrc_script
}

#page
#### adding unsafe users

function script_before_parsing_options_ADD () {
    script_USAGE="usage: ${script_PROGNAME} add [options] UNSAFE-USERNAME"
    script_DESCRIPTION='Add an unsafe user.'
    mbfl_declare_option UNSAFE_USERS_HOME_BASE_DIRECTORY "$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY" \
			'' unsafe-home-base witharg 'Select the base directory for the unsafe users\x27 home directories.'
    mbfl_declare_option SAFE_USERNAME '' S safe-user witharg 'Select the name of the safe user.'
}
function script_action_ADD () {
    if ! mbfl_wrong_num_args 1 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    # Determine the safe username.
    {
	mbfl_local_varref(SAFE_USERNAME)
	determine_safe_username_var mbfl_datavar(SAFE_USERNAME)
    }

    # Determine the unsafe username.
    {
	mbfl_command_line_argument(UNSAFE_USERNAME, 0)
	if ! mbfl_string_is_username "$UNSAFE_USERNAME"
	then
	    mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	    exit_because_failure
	fi
    }

    # Determine the base directory for unsafe users' home directories.
    {
	mbfl_local_varref(UNSAFE_USERS_HOME_BASE_DIRECTORY)
	determine_base_directory_for_unsafe_users_home_directories_var mbfl_datavar(UNSAFE_USERS_HOME_BASE_DIRECTORY)
    }

    # Invoke this script itself to perform the operations.
    {
	mbfl_local_varref(SUBSCRIPT_FLAGS)
	mbfl_getopts_gather_mbfl_options_var mbfl_datavar(SUBSCRIPT_FLAGS)

	mbfl_program_declare_sudo_user root
	if {
	    mbfl_location_enter
	    {
		mbfl_option_test_save; mbfl_location_handler mbfl_option_test_restore
		mbfl_program_exec "$SCRIPT_ARGV0" sudo-add				\
				  "$SAFE_USERNAME" "$UNSAFE_USERNAME"			\
				  "$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY"	\
				  $SUBSCRIPT_FLAGS
	    }
	    mbfl_location_leave
	}
	then exit_success
	else
    	    mbfl_message_error 'adding user'
    	    exit_because_failure
	fi
    }
}

### ------------------------------------------------------------------------

function script_before_parsing_options_SUDO_ADD () {
    script_USAGE="usage: ${script_PROGNAME} sudo-add SAFE-USERNAME UNSAFE-USERNAME UNSAFE_USERS_HOME_BASE_DIRECTORY [options]"
    script_DESCRIPTION='Internal action.'
}
function script_action_SUDO_ADD () {
    if ! mbfl_wrong_num_args 3 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_command_line_argument(SAFE_USERNAME,                    0)
    mbfl_command_line_argument(UNSAFE_USERNAME,                  1)
    mbfl_command_line_argument(UNSAFE_USERS_HOME_BASE_DIRECTORY, 2)
    local -r UNSAFE_HOME="${UNSAFE_USERS_HOME_BASE_DIRECTORY}/${UNSAFE_USERNAME}"

    validate_safe_username "$SAFE_USERNAME"
    validate_unsafe_username "$UNSAFE_USERNAME"
    validate_base_directory_for_unsafe_users_home_directories "$UNSAFE_USERS_HOME_BASE_DIRECTORY"

    # Create the unsafe user.  We  assume there exists a group with the same  name of the safe user.
    # We create a group with the same name of the unsafe user.
    mbfl_message_verbose_printf 'creating unsafe user: "%s"\n' "$UNSAFE_USERNAME"
    if ! mbfl_program_exec "$self_PROGRAM_USERADD"			\
	 --base-dir		"$UNSAFE_USERS_HOME_BASE_DIRECTORY"	\
	 --home			"$UNSAFE_HOME"				\
	 --create-home							\
	 --user-group							\
	 --groups		$UNSAFE_USERS_GROUP,audio,video		\
	 --shell		/bin/false				\
	 "$UNSAFE_USERNAME"
    then
	mbfl_message_error_printf 'creating unsafe user: "%s"' "$UNSAFE_USERNAME"
	mbfl_file_remove_directory_silently "$UNSAFE_HOME"
	exit_because_failure
    fi

    # Set permissions for the unsafe user's home directory.
    if ! mbfl_file_set_permissions $DEFAULT_UNSAFE_USERHOME_MODE "$UNSAFE_HOME" --recursive
    then mbfl_message_error 'setting permissions to unsafe user home'
    fi

    # Add safe user to the unsafe user's group.
    if ! mbfl_program_exec "$self_PROGRAM_USERMOD" "$SAFE_USERNAME" --append --groups "$UNSAFE_USERNAME"
    then
	mbfl_message_error "adding safe user to unsafe user's group"
    fi

    # Create a  "~/.plan" text file in  the unsafe user home  directory.  It is used  by the program
    # "finger"  to display  descriptive informations  about  the user  profile; see  the manpage  of
    # "finger" for details.
    printf 'Unsafe user account associated to the user "%s".

This user profile was created by the package MMUX Unsafe Users Management.\n' "$SAFE_USERNAME" >"$UNSAFE_HOME"/.plan
}

#page
#### deleting unsafe users

function script_before_parsing_options_DEL () {
    script_USAGE="usage: ${script_PROGNAME} del UNSAFE-USERNAME --safe-user=SAFE-USERNAME [options]"
    script_DESCRIPTION='Remove an unsafe user.'
    mbfl_declare_option SAFE_USERNAME '' S safe-user witharg 'Select the name of the safe user.'
}
function script_action_DEL () {
    if ! mbfl_wrong_num_args 1 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_command_line_argument(UNSAFE_USERNAME, 0)
    local SAFE_USERNAME=$script_option_SAFE_USERNAME
    mbfl_local_varref(SUBSCRIPT_FLAGS)

    if ! mbfl_string_is_username "$SAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_failure
    fi
    if ! mbfl_string_is_username "$UNSAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	exit_because_failure
    fi

    mbfl_getopts_gather_mbfl_options_var mbfl_datavar(SUBSCRIPT_FLAGS)
    mbfl_program_declare_sudo_user root
    if mbfl_program_exec "$SCRIPT_ARGV0" sudo-del "$SAFE_USERNAME" "$UNSAFE_USERNAME" $SUBSCRIPT_FLAGS
    then exit_success
    else
    	mbfl_message_error 'deleting user'
    	exit_because_failure
    fi
}

### ------------------------------------------------------------------------

function script_before_parsing_options_SUDO_DEL () {
    script_USAGE="usage: ${script_PROGNAME} sudo-del SAFE-USERNAME UNSAFE-USERNAME [options]"
    script_DESCRIPTION='Internal action.'
}
function script_action_SUDO_DEL () {
    if ! mbfl_wrong_num_args 2 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_command_line_argument(SAFE_USERNAME,   0)
    mbfl_command_line_argument(UNSAFE_USERNAME, 1)

    if ! mbfl_string_is_username "$SAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_failure
    fi
    if ! mbfl_string_is_username "$UNSAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	exit_because_failure
    fi

    if mbfl_option_interactive
    then
	local MESSAGE
	printf -v MESSAGE 'delete the user "%s"' "$UNSAFE_USERNAME"
	if ! mbfl_dialog_yes_or_no "$MESSAGE"
	then
	    mbfl_message_verbose_printf 'skipping deletion of user: "%s"\n' "$UNSAFE_USERNAME"
	    exit_success
	fi
    fi

    mbfl_message_verbose_printf 'deleting user: "%s"\n' "$UNSAFE_USERNAME"
    if ! mbfl_program_exec "$self_PROGRAM_USERDEL" "$UNSAFE_USERNAME" --remove
    then mbfl_message_error_printf 'removing unsafe user: "%s"' "$UNSAFE_USERNAME"
    fi

    # When "groupdel" removes the unsafe group: it also  removes it from the list of groups of which
    # the safe user is part.
    mbfl_message_verbose_printf 'deleting group: "%s"\n' "$UNSAFE_USERNAME"
    if ! mbfl_program_exec "$self_PROGRAM_GROUPDEL" "$UNSAFE_USERNAME"
    then mbfl_message_error_printf 'removing unsafe group: "%s"' "$UNSAFE_USERNAME"
    fi
}

#page
#### enabling access to X host

function script_before_parsing_options_ENABLE_X () {
    script_USAGE="usage: ${script_PROGNAME} enable-x [options]"
    script_DESCRIPTION='Enable unsafe users running X applications in safe user X server.'
    mbfl_declare_option SAFE_USERNAME '' S safe-user witharg 'Select the name of the safe user.'
}
function script_action_ENABLE_X () {
    if ! mbfl_wrong_num_args 0 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_local_varref(XHOST)
    mbfl_program_found_var mbfl_datavar(XHOST)	xhost || exit $?

    mbfl_message_verbose_printf 'acquire safe username\n'
    mbfl_local_varref(SAFE_USERNAME, "$script_option_SAFE_USERNAME")
    if mbfl_string_is_empty "$SAFE_USERNAME"
    then mbfl_system_whoami_var mbfl_datavar(SAFE_USERNAME)
    fi
    if mbfl_string_is_empty "$SAFE_USERNAME"
    then
	mbfl_message_error 'missing safe username option selection'
	exit_because_failure
    fi
    if ! mbfl_string_is_username "$SAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_failure
    fi

    mbfl_message_verbose_printf 'enabling X host access control\n'
    if ! mbfl_program_exec "$XHOST" -
    then
	mbfl_message_error 'enabling X host access control'
	exit_because_failure
    fi

    mbfl_local_varref(UNSAFE_USERS_LIST_FILE)
    determine_unsafe_users_list_file_var mbfl_datavar(UNSAFE_USERS_LIST_FILE) "$SAFE_USERNAME"

    local UNSAFE_USERNAME
    mbfl_file_read "$UNSAFE_USERS_LIST_FILE" | while read UNSAFE_USERNAME
    do
	if ! mbfl_string_is_username "$UNSAFE_USERNAME"
	then
	    mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	    exit_because_failure
	fi

	mbfl_message_verbose_printf 'enabling unsafe user running X applications: "%s"\n' "$UNSAFE_USERNAME"

	if ! mbfl_program_exec "$XHOST" "+local:$UNSAFE_USERNAME"
	then
	    mbfl_message_error 'enabling unsafe user running X applications'
	    exit_because_failure
	fi
    done
}

#page
#### disabling access to X host

function script_before_parsing_options_DISABLE_X () {
    script_USAGE="usage: ${script_PROGNAME} disable-x [options]"
    script_DESCRIPTION='Disable unsafe users running X applications in safe user X server.'
    mbfl_declare_option SAFE_USERNAME '' S safe-user witharg 'Select the name of the safe user.'
}
function script_action_DISABLE_X () {
    if ! mbfl_wrong_num_args 0 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_local_varref(XHOST)
    mbfl_program_found_var mbfl_datavar(XHOST)	xhost || exit $?

    mbfl_message_verbose_printf 'acquire safe username\n'
    mbfl_local_varref(SAFE_USERNAME, "$script_option_SAFE_USERNAME")
    if mbfl_string_is_empty "$SAFE_USERNAME"
    then mbfl_system_whoami_var mbfl_datavar(SAFE_USERNAME)
    fi
    if mbfl_string_is_empty "$SAFE_USERNAME"
    then
	mbfl_message_error 'missing safe username option selection'
	exit_because_failure
    fi
    if ! mbfl_string_is_username "$SAFE_USERNAME"
    then
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_failure
    fi

    mbfl_local_varref(UNSAFE_USERS_LIST_FILE)
    determine_unsafe_users_list_file_var mbfl_datavar(UNSAFE_USERS_LIST_FILE) "$SAFE_USERNAME"

    local UNSAFE_USERNAME
    mbfl_file_read "$UNSAFE_USERS_LIST_FILE" | while read UNSAFE_USERNAME
    do
	if ! mbfl_string_is_username "$UNSAFE_USERNAME"
	then
	    mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	    exit_because_failure
	fi

	mbfl_message_verbose_printf 'enabling unsafe user running X applications: "%s"\n' "$UNSAFE_USERNAME"

	if ! mbfl_program_exec "$XHOST" "-local:$UNSAFE_USERNAME"
	then
	    mbfl_message_error 'enabling unsafe user running X applications'
	    exit_because_failure
	fi
    done
}

#page
#### home directories normalisation

function script_before_parsing_options_NORMALISE () {
    script_USAGE="usage: ${script_PROGNAME} normalise [options]"
    script_DESCRIPTION='Normalise the home directories of unsafe users associated to a single safe user.\n
If the SAFE_USERNAME is not given on the command line: it is determined
using the program "whoami" from the GNU Coreutils.'
    mbfl_declare_option SAFE_USERNAME   '' S safe-user       witharg 'Select the name of the safe user.'
    mbfl_declare_option UNSAFE_USERNAME '' U unsafe-username witharg 'Select a single unsafe user whose directory we want to normalise.'
}
function script_action_NORMALISE () {
    if ! mbfl_wrong_num_args 0 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    mbfl_local_varref(SAFE_USERNAME)
    determine_safe_username_var mbfl_datavar(SAFE_USERNAME)

    # Determine the unsafe username.
    {
	mbfl_local_varref(UNSAFE_USERNAME, "$script_option_UNSAFE_USERNAME")
	if mbfl_string_is_not_empty "$UNSAFE_USERNAME"
	then
	    if ! mbfl_string_is_username "$UNSAFE_USERNAME"
	    then
		mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
		exit_because_failure
	    fi
	    mbfl_message_verbose_printf 'the selected unsafe user name is: "%s"\n' "$UNSAFE_USERNAME"
	    mbfl_message_verbose_printf 'unsafe user selected, so ignoring the safe user name: "%s"\n'      "$SAFE_USERNAME"
	fi
    }

    # Execute the script itself, invoking the action "sudo-normalise".
    {
	mbfl_local_varref(SUBSCRIPT_FLAGS)
	mbfl_getopts_gather_mbfl_options_var mbfl_datavar(SUBSCRIPT_FLAGS)

	mbfl_program_declare_sudo_user root
	if {
	    mbfl_option_test_save
	    mbfl_program_exec "$SCRIPT_ARGV0" sudo-normalise $SUBSCRIPT_FLAGS '--' "$SAFE_USERNAME" "$UNSAFE_USERNAME"
	    mbfl_option_test_restore
	}
	then exit_success
	else
    	    mbfl_message_error 'normalising unsafe users directories'
    	    exit_because_failure
	fi
    }
}

### ------------------------------------------------------------------------

function script_before_parsing_options_SUDO_NORMALISE () {
    script_USAGE="usage: ${script_PROGNAME} sudo-normalise [options] SAFE_USERNAME UNSAFE_USERNAME"
    script_DESCRIPTION='Internal action.'
}
function script_action_SUDO_NORMALISE () {
    if ! mbfl_wrong_num_args 2 $ARGC
    then
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi

    # Acquire the safe username.
    {
	mbfl_command_line_argument(SAFE_USERNAME, 0)
	if ! mbfl_string_is_username "$SAFE_USERNAME"
	then
	    mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	    exit_because_failure
	fi
    }

    # Acquire the unsafe username.
    {
	mbfl_command_line_argument(UNSAFE_USERNAME, 1)
	if mbfl_string_is_not_empty "$UNSAFE_USERNAME"
	then
	    if ! mbfl_string_is_username "$UNSAFE_USERNAME"
	    then
		mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
		exit_because_failure
	    fi
	fi
    }

    # Perform the requested normalisation.
    {
	if mbfl_string_is_empty "$UNSAFE_USERNAME"
	then normalise_unsafe_users_home_directories     "$SAFE_USERNAME"
	else normalise_single_unsafe_user_home_directory "$SAFE_USERNAME" "$UNSAFE_USERNAME"
	fi
    }
}

### ------------------------------------------------------------------------

function normalise_unsafe_users_home_directories () {
    mbfl_mandatory_parameter(SAFE_USERNAME, 1, safe user name)

    mbfl_local_varref(UNSAFE_USERS_LIST_FILE)
    determine_unsafe_users_list_file_var mbfl_datavar(UNSAFE_USERS_LIST_FILE) "$SAFE_USERNAME"
    mbfl_message_verbose_printf 'reading unsafe users list from: "%s"\n' "$UNSAFE_USERS_LIST_FILE"

    local UNSAFE_USERNAME
    {
	mbfl_location_enter
	{
	    mbfl_option_test_save; mbfl_location_handler mbfl_option_test_restore
	    mbfl_file_read "$UNSAFE_USERS_LIST_FILE"
	}
	mbfl_location_leave
    } | while read UNSAFE_USERNAME
    do normalise_single_unsafe_user_home_directory "$SAFE_USERNAME" "$UNSAFE_USERNAME"
    done
}

### ------------------------------------------------------------------------

function normalise_single_unsafe_user_home_directory () {
    mbfl_mandatory_parameter(SAFE_USERNAME,   1, safe user name)
    mbfl_mandatory_parameter(UNSAFE_USERNAME, 2, unsafe user name)
    local -r UNSAFE_GROUPNAME=$UNSAFE_USERNAME

    mbfl_message_verbose_printf 'processing unsafe user: "%s"\n' "$UNSAFE_USERNAME"

    mbfl_local_varref(UNSAFE_USER_INDEX)
    mbfl_local_varref(UNSAFE_USERHOME)

    read_passwd_data
    mbfl_system_passwd_find_entry_by_name_var mbfl_datavar(UNSAFE_USER_INDEX) "$UNSAFE_USERNAME"
    mbfl_system_passwd_get_dir_var            mbfl_datavar(UNSAFE_USERHOME)   "$UNSAFE_USER_INDEX"
    mbfl_message_verbose_printf 'the index of the unsafe user is: "%s"\n'   "$UNSAFE_USER_INDEX"
    mbfl_message_verbose_printf 'the unsafe user home directory is: "%s"\n' "$UNSAFE_USERHOME"

    if mbfl_file_is_directory "$UNSAFE_USERHOME"
    then
	local -r USERHOME_PERMISSIONS=$DEFAULT_UNSAFE_USERHOME_MODE

	mbfl_message_verbose_printf 'setting permissions to %s for unsafe user home: "%s"\n' $USERHOME_PERMISSIONS "$UNSAFE_USERHOME"
	if ! mbfl_file_set_permissions $USERHOME_PERMISSIONS "$UNSAFE_USERHOME"
	then mbfl_message_error_printf 'setting permissions to %s for unsafe user home: "%s"' $USERHOME_PERMISSIONS "$UNSAFE_USERHOME"
	fi

	mbfl_message_verbose_printf 'setting owner to "%s" for unsafe user home: "%s"\n' "$UNSAFE_USERNAME" "$UNSAFE_USERHOME"
	if ! mbfl_file_set_owner "$UNSAFE_USERNAME" "$UNSAFE_USERHOME"
	then mbfl_message_error_printf 'setting owner to "%s" for unsafe user home: "%s"' "$UNSAFE_USERNAME" "$UNSAFE_USERHOME"
	fi

	mbfl_message_verbose_printf 'setting group to "%s" for unsafe user home: "%s"\n' "$UNSAFE_GROUPNAME" "$UNSAFE_USERHOME"
	if ! mbfl_file_set_group "$UNSAFE_GROUPNAME" "$UNSAFE_USERHOME"
	then mbfl_message_error_printf 'setting group to "%s" for unsafe user home: "%s"' "$UNSAFE_GROUPNAME" "$UNSAFE_USERHOME"
	fi
    else
	mbfl_message_error_printf 'unexistent unsafe user directory: "%s"' "$UNSAFE_USERHOME"
	continue
    fi

    local FIND
    local CHOWN="$mbfl_PROGRAM_CHOWN" CHOWN_FLAGS='--no-dereference'
    local CHMOD="$mbfl_PROGRAM_CHMOD" CHMOD_FLAGS
    mbfl_program_found_var FIND find || exit $?

    if mbfl_option_verbose
    then
	CHOWN_FLAGS+=' --changes'
	CHMOD_FLAGS+=' --changes'
    fi
    if mbfl_option_verbose_program
    then
	CHOWN_FLAGS+=' --verbose'
	CHMOD_FLAGS+=' --verbose'
    fi

    local -r OWNER_GROUP="${UNSAFE_USERNAME}:${UNSAFE_GROUPNAME}"
    local -r DIRECTORY_PERMISSIONS=$DEFAULT_UNSAFE_USERHOME_DIRECTORIES_MODE
    local -r FILE_PERMISSIONS=$DEFAULT_UNSAFE_USERHOME_FILES_MODE

    mbfl_message_verbose_printf 'normalising permissions for entries in unsafe user home directory: "%s"\n' "$UNSAFE_USERHOME"
    mbfl_message_verbose_printf 'setting owner and group to "%s"\n'         "$OWNER_GROUP"
    mbfl_message_verbose_printf 'changing directory permissions to: "%s"\n' "$DIRECTORY_PERMISSIONS"
    mbfl_message_verbose_printf 'changing file permissions to: "%s"\n'      "$FILE_PERMISSIONS"

    #mbfl_program_declare_sudo_user "$UNSAFE_USERNAME"
    if ! mbfl_program_exec "$FIND" "$UNSAFE_USERHOME"						         \
	 '(' -type d -and -name '{git}'          -and -prune ')'				    -or  \
	 '(' -type d -and -name '{archives}'     -and -prune ')'				    -or  \
	 '('                                                                                             \
	 '(' -exec "$CHOWN" "$OWNER_GROUP"                       $CHOWN_FLAGS '--' '{}' ';' ')'     -and \
	 '('                                                                                             \
	 '(' -type d -and -exec "$CHMOD" $DIRECTORY_PERMISSIONS  $CHMOD_FLAGS '--' '{}' ';' ')'     -or  \
	 '(' -type f -and -exec "$CHMOD" $FILE_PERMISSIONS       $CHMOD_FLAGS '--' '{}' ';' ')'          \
         ')'                                                                                             \
	 ')'
    then
	mbfl_message_error_printf 'setting owner, group ad permissions for entries in unsafe user home directory: "%s"' "$UNSAFE_USERHOME"
	return_because_failure
    fi
}

#page
#### help actions

function script_before_parsing_options_HELP () {
    script_USAGE="usage: ${script_PROGNAME} help [action] [options]"
    script_DESCRIPTION='Help the user of this program.'
}
function script_action_HELP () {
    # By faking the  selection of the MAIN action: we  cause "mbfl_main_print_usage_screen_brief" to
    # print the main usage screen.
    mbfl_actions_fake_action_set MAIN
    mbfl_main_print_usage_screen_brief
}

### ------------------------------------------------------------------------

function script_before_parsing_options_HELP_USAGE () {
    script_USAGE="usage: ${script_PROGNAME} help usage [options]"
    script_DESCRIPTION='Print the usage screen and exit.'
}
function script_action_HELP_USAGE () {
    if mbfl_wrong_num_args 0 $ARGC
    then
	# By faking the selection of  the MAIN action: we cause "mbfl_main_print_usage_screen_brief"
	# to print the main usage screen.
	mbfl_actions_fake_action_set MAIN
	mbfl_main_print_usage_screen_brief
    else
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi
}

## --------------------------------------------------------------------

function script_before_parsing_options_HELP_PRINT_COMPLETIONS_SCRIPT () {
    script_PRINT_COMPLETIONS="usage: ${script_PROGNAME} help print-completions-script [options]"
    script_DESCRIPTION='Print the command-line completions script and exit.'
}
function script_action_HELP_PRINT_COMPLETIONS_SCRIPT () {
    if mbfl_wrong_num_args 0 $ARGC
    then mbfl_actions_completion_print_script "$COMPLETIONS_SCRIPT_NAMESPACE" "$script_PROGNAME"
    else
	mbfl_main_print_usage_screen_brief
	exit_because_wrong_num_args
    fi
}

#page
#### reading external files

declare PASSWD_DATA_ALREADY_READ=false
function read_passwd_data () {
    if $PASSWD_DATA_ALREADY_READ
    then return_success
    else
	mbfl_message_verbose_printf 'reading users data from: "/etc/passwd"\n'
	mbfl_system_passwd_reset
	mbfl_option_test_save
	{
	    if ! mbfl_system_passwd_read
	    then
		mbfl_message_error_printf 'unable to acquire users data'
		exit_because_failure
	    fi
	}
	mbfl_option_test_restore
	PASSWD_DATA_ALREADY_READ=true
    fi
}

#page
#### setup helper functions
#
# We are supposed to invoke the "setup_*()" functions with the access permissions of the superuser.
#

function setup_create_safe_users_group () {
    local -r TEMPLATE='creating safe users groups: "%s"'

    mbfl_message_verbose_printf "${TEMPLATE}\n" "$SAFE_USERS_GROUP"
    if ! mbfl_program_exec "$self_PROGRAM_GROUPADD" --force "$SAFE_USERS_GROUP"
    then
	mbfl_message_error_printf "$TEMPLATE" "$SAFE_USERS_GROUP"
	exit_because_failure
    fi
}
function setup_create_unsafe_users_group () {
    local -r TEMPLATE='creating unsafe users groups: "%s"'

    mbfl_message_verbose_printf "${TEMPLATE}\n" "$UNSAFE_USERS_GROUP"
    if ! mbfl_program_exec "$self_PROGRAM_GROUPADD" --force "$UNSAFE_USERS_GROUP"
    then
	mbfl_message_error_printf "$TEMPLATE" "$UNSAFE_USERS_GROUP"
	exit_because_failure
    fi
}

### ------------------------------------------------------------------------

# We are supposed to call this function when we have the access permissions of the superuser.
#
function setup_create_base_directory_for_unsafe_users_home_directories () {
    mbfl_mandatory_parameter(UNSAFE_USERS_HOME_BASE_DIRECTORY, 1, base directory for unsafe users home directories)
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE

    setup_p_create_directory					\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY"			\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER"		\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP"		\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE"		\
	'base directory for unsafe users\x27 home directories'
}

# We are supposed to call this function when we have the access permissions of the superuser.
#
function setup_normalise_base_directory_for_unsafe_users_home_directories () {
    mbfl_mandatory_parameter(UNSAFE_USERS_HOME_BASE_DIRECTORY, 1, base directory for unsafe users home directories)
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP
    local -r UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE=$DEFAULT_UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE

    setup_normalise_directory					\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY"			\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_OWNER"		\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_GROUP"		\
	"$UNSAFE_USERS_HOME_BASE_DIRECTORY_MODE"		\
	'base directory for unsafe users\x27 home directories'
}

### ------------------------------------------------------------------------

function setup_normalise_this_script_itself () {
    setup_normalise_file					\
	"$MANAGER_SCRIPT_PATHNAME"				\
	'root'							\
	"$SAFE_USERS_GROUP"					\
	'0750'							\
	'manager script file'
}

### ------------------------------------------------------------------------

function setup_create_xinitrc_directory () {
    setup_p_create_directory					\
	"$MMUX_XINITRC_DIRECTORY_PATHNAME"			\
	'root'							\
	'root'							\
	'0755'							\
	'MMUX xinitrc directory'
}
function setup_normalise_xinitrc_directory () {
    setup_normalise_directory					\
	"$MMUX_XINITRC_DIRECTORY_PATHNAME"			\
	'root'							\
	'root'							\
	'0755'							\
	'MMUX xinitrc directory'
}
function setup_normalise_xinitrc_script () {
    setup_normalise_file					\
	"$MMUX_XINITRC_SCRIPT_PATHNAME"				\
	'root'							\
	"$SAFE_USERS_GROUP"					\
	'0750'							\
	'manager script directory'
}

### ------------------------------------------------------------------------

function setup_normalise_sudoers_conf_directory () {
    setup_normalise_directory					\
	"$SUDOERS_CONF_DIRECTORY_PATHNAME"			\
	'root'							\
	'root'							\
	'0755'							\
	'sudoers conf directory'
}
function setup_normalise_sudoers_conf_file () {
    setup_normalise_file					\
	"$SUDOERS_CONF_FILE_PATHNAME"				\
	'root'							\
	'root'							\
	'0400'							\
	'sudoers conf file'
}

### ------------------------------------------------------------------------

function setup_p_create_directory () {
    mbfl_mandatory_parameter(DIRECTORY_PATHNAME,    1, directory pathname)
    mbfl_mandatory_parameter(DIRECTORY_OWNER,       2, directory owner)
    mbfl_mandatory_parameter(DIRECTORY_GROUP,       3, directory group)
    mbfl_mandatory_parameter(DIRECTORY_MODE,        4, directory mode)
    # We use  the printf format directive  "%b" to print the  description, so we expand  some of the
    # backslash escape sequences.
    mbfl_mandatory_parameter(DIRECTORY_DESCRIPTION, 5, description)
    local -r TEMPLATE='creating %b: "%s"'

    mbfl_message_verbose_printf "${TEMPLATE}\n" "$DIRECTORY_DESCRIPTION" "$DIRECTORY_PATHNAME"
    mbfl_message_verbose_printf 'directory owner: "%s"' "$DIRECTORY_OWNER"
    mbfl_message_verbose_printf 'directory group: "%s"' "$DIRECTORY_GROUP"
    mbfl_message_verbose_printf 'directory mode: "%s"'  "$DIRECTORY_MODE"

    local INSTALL_FLAGS
    printf -v INSTALL_FLAGS '--mode=%s --owner=%s --group=%s --directory' \
	   "$DIRECTORY_MODE" "$DIRECTORY_OWNER" "$DIRECTORY_GROUP"

    if program_install $INSTALL_FLAGS '--' "$DIRECTORY_PATHNAME"
    then
	mbfl_message_error_printf "$TEMPLATE" "$DIRECTORY_DESCRIPTION" "$DIRECTORY_PATHNAME"
	exit_because_failure
    fi
}

#page
#### miscellaneous value determination

# Determine the safe username.  If the command  line option "--safe-user" has been used: gather that
# value; otherwise gather the name of the effective user running this script.
#
function determine_safe_username_var () {
    mbfl_mandatory_nameref_parameter(SAFE_USERNAME, 1, result variable)

    if mbfl_string_is_not_empty "$script_option_SAFE_USERNAME"
    then SAFE_USERNAME=$script_option_SAFE_USERNAME
    else determine_effective_user_name_var mbfl_datavar(SAFE_USERNAME)
    fi
    if mbfl_string_is_username "$SAFE_USERNAME"
    then
	mbfl_message_verbose_printf 'the selected safe user name is: "%s"\n' "$SAFE_USERNAME"
	return_success
    else
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_failure
    fi
}

# Determine the  name of the effective  user running this  script, by calling the  external "whoami"
# from the GNU Coreutils.
#
function determine_effective_user_name_var () {
    mbfl_mandatory_nameref_parameter(SAFE_USERNAME, 1, result variable)

    if ! {
	    mbfl_location_enter
	    {
		mbfl_option_test_save; mbfl_location_handler mbfl_option_test_restore
		mbfl_system_whoami_var mbfl_datavar(SAFE_USERNAME)
	    }
	    mbfl_location_leave
	}
    then
	mbfl_message_error_printf 'unable to determine effective user with "whoami"'
	exit_because_unable_to_determine_effective_username
    fi
}

# Determine   the  base   directory   for   unsafe  users'   home   directories.    If  the   option
# "--unsafe-home-base" is  used: gather that  value; otherwise use the  default value in  the global
# variable "$UNSAFE_USERS_HOME_BASE_DIRECTORY".
#
function determine_base_directory_for_unsafe_users_home_directories_var () {
    mbfl_mandatory_nameref_parameter(UNSAFE_USERS_HOME_BASE_DIRECTORY, 1, result variable)

    if mbfl_string_is_empty "$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY"
    then
	mbfl_message_error_printf \
	    "invalid empty unsafe users' base directory for home directories, selected with the command line option \"--unsafe-home-base\""
	exit_because_failure
    fi

    if ! mbfl_file_is_directory "$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY"
    then
	mbfl_message_error_printf \
	    'the selected pathname for the base directory of unsafe users home directories is not a directory: "%s"' \
	    "$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY"
	exit_because_failure
    fi

    UNSAFE_USERS_HOME_BASE_DIRECTORY="$script_option_UNSAFE_USERS_HOME_BASE_DIRECTORY"
    return_success
}

function determine_unsafe_users_list_file_var () {
    mbfl_mandatory_nameref_parameter(UNSAFE_USERS_LIST_FILE, 1, result variable)
    mbfl_mandatory_parameter(SAFE_USERNAME,                  2, safe user name)
    mbfl_local_varref(SAFE_USER_INDEX)
    mbfl_local_varref(SAFE_USERHOME)

    read_passwd_data
    mbfl_system_passwd_find_entry_by_name_var mbfl_datavar(SAFE_USER_INDEX) "$SAFE_USERNAME"
    mbfl_system_passwd_get_dir_var            mbfl_datavar(SAFE_USERHOME)   "$SAFE_USER_INDEX"

    printf -v UNSAFE_USERS_LIST_FILE '%s/.mmux-unsafe-users' "$SAFE_USERHOME"
    if ! mbfl_file_is_readable "$UNSAFE_USERS_LIST_FILE"
    then
	mbfl_message_error_printf 'unexistent or unreadable unsafe users list file: "%s"' "$UNSAFE_USERS_LIST_FILE"
	exit_because_failure
    fi
}

#page
#### miscellaneous values validation

function validate_safe_username () {
    mbfl_mandatory_parameter(SAFE_USERNAME, 0, safe user name)

    if mbfl_string_is_username "$SAFE_USERNAME"
    then return_success
    else
	mbfl_message_error_printf 'invalid safe username: "%s"' "$SAFE_USERNAME"
	exit_because_invalid_safe_username
    fi
}

function validate_unsafe_username () {
    mbfl_mandatory_parameter(UNSAFE_USERNAME, 0, unsafe user name)

    if mbfl_string_is_username "$UNSAFE_USERNAME"
    then return_success
    else
	mbfl_message_error_printf 'invalid unsafe username: "%s"' "$UNSAFE_USERNAME"
	exit_because_invalid_unsafe_username
    fi
}

# Checks that the  given pathname of base directory  for unsafe users home directories  is usable to
# create subdirectories in.
#
function validate_base_directory_for_unsafe_users_home_directories () {
    mbfl_mandatory_parameter(UNSAFE_USERS_HOME_BASE_DIRECTORY, 1, pathname of base directory for unsafe users home directories)

    if ! mbfl_file_is_directory "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
    then
	mbfl_message_error_printf \
	    'the pathname for the base directory for unsafe users home directories is not a directory: "%s"' \
	    "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
	exit_because_invalid_base_directory_for_unsafe_users_home_directories
    fi
    if ! mbfl_file_is_writable "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
    then
	mbfl_message_error_printf \
	    'the pathname for the base directory for unsafe users home directories is not writable: "%s"' \
	    "$UNSAFE_USERS_HOME_BASE_DIRECTORY"
	exit_because_invalid_base_directory_for_unsafe_users_home_directories
    fi
    return_success
}

#page
#### interfaces to external programs

function program_install () {
    local INSTALL_FLAGS

    if mbfl_option_verbose_program
    then INSTALL_FLAGS+=' --verbose'
    fi
    mbfl_program_exec "$self_PROGRAM_INSTALL" $INSTALL_FLAGS "$@"
}

#page
#### let's go

function main () {
    mbfl_main_print_usage_screen_brief
}
mbfl_main

### end of file
# Local Variables:
# mode: sh
# End:
